/*
В файле pom - правая кнопка мыши - Maven - Reload project и Generate sources and update folders после добавления dependencies

Test Case
(тестовый сценарий)

Артефакт, описывающий совокупность шагов, конкретных условий и параметров,
необходимых для проверки реализации тестируемой функции или ее части

Под тест кейсом понимается структура вида:
Action > Expected Result > Test Result

Пример:
Open page "login" > Login page is opened > Passed
---------------------------------------------------------------------

Уровни тестирования

- Модульное тестирование
проверка работы программы на уровне отдельных модулей (классов, методов)

- Интеграционное тестирование
проверка совместной работы нескольких модулей

- Системное тестирование
проверка работы системы в целом
-------------------------------------------------------------------------

Модульное (unit) тестирование
Процесс проверки корректности работы отдельных частей исходного кода
(чаще всего методов) программы путем запуска тестов в искусственной среде
ОСУЩЕСТВЛЯЕТСЯ РАЗРАБОТЧИКОМ!


Что делает тест?
1. Воспроизводит некоторые данные / делает предварительны действия.
2. Выполняет тестируемый метод, правильный результат работы которого
очевиден автору теста
3. Выполняет сопоставление полученного результата с ожидаемым (assert).
Если "ожидание" и "реальность" совпадают, тест пройден. Если нет -
тест завален (чаще всего генерируется специлаьное исключение -
AssertionError)


Зачем нужно модульное тестирование?
- Разработчик создает методы и классы для конкретных целей
- Снижается число новых ошибок при добавлении новой функциональности
- Тест отражает элементы технического задания, (некорректное завершение
теста сообщает о нарушении технических требований заказчика)
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------

1. Каждый тестовый сценарий (test case) - отдельный метод.
Методы необходимо помечать аннотацией @Test

2. Существуют вспомогательные методы с аннотациями @Before, @BeforeClass, @After,
@AfterClass (о них в следующем уроке)

3. Тестовый класс необходимо называть с суффиксом Test (например Vector2ВTest)

4. Тестовые методы желательно должны содержать "should" в названии
(например sumShouldBePositive)
-----------------------------------------------------------------------------------

Аннотация @Test объявляет метод (обязательно public void) тестовым

Аннотация @Test может использовать параметры:
- expected - код в тесте проверяется на генерацию определенного исключения
- timeout - код в тесте должен работать не более указанного времени (иначе тест завален)

org.junit.Assert
Проверка "ожидание/реальность" (expected/actual)


Методы:
- assertTrue()
- assertFalse()
- assertEquals()
- assertArrayEquals()
- assertNotEquals()
- assertSame()
- assertNotSame()

fail - гарантированное падение теста
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

Ignore и Assume
Тест, помеченный @Ignore, не выполняется
- Лучше это не использовать!

Вместо Assert можно использовать Assume
(с методами assumeFalse, assumeEquals и др.):
- Если проверка верна - тест пройден
- Если проверка неверна - тест игнорируется
----------------------------------------------------------

Вспомогательные методы
- @BeforeClass - запускается только один раз при запуске теста (static)
- @Before - запускается перед каждым тестовым методом
- @After - запускается после каждого метода
- @AfterClass - запускается после того, как отработали все тестовые методы (static)
-----------------------------------------------------------------------------------

Жизненный цикл тестирующего класса
- @BeforeClass
- Для каждого @Test-метода:
создание экземпляра тестового класса
@Before
@Test
@After
- @AfterClass


 */
